/**
 * Fun loading messages to keep users entertained while waiting
 * 趣味等待提示语，让用户在等待时保持愉悦
 */

// General loading messages for document/page loading
// 通用加载提示语
export const generalLoadingMessages = [
  { zh: '泡壶茶，AI正在追逐灵感...', en: 'Brewing tea while AI chases inspiration...' },
  { zh: '咖啡还没凉，稍等片刻...', en: 'Coffee is still warm, just a moment...' },
  { zh: '数据精灵正在搬砖中...', en: 'Data elves are working hard...' },
  { zh: '正在召唤知识的力量...', en: 'Summoning the power of knowledge...' },
  { zh: '让我们给大脑一点思考时间...', en: 'Let\'s give the brain some thinking time...' },
  { zh: '好东西值得等待...', en: 'Good things are worth waiting for...' },
  { zh: '正在翻阅古籍寻找答案...', en: 'Flipping through ancient texts...' },
  { zh: '思维齿轮转动中...', en: 'Mental gears are turning...' },
  { zh: '正在连接创意宇宙...', en: 'Connecting to the creative universe...' },
  { zh: '文字炼金术进行中...', en: 'Word alchemy in progress...' },
];

// Analysis-specific loading messages
// 分析相关提示语
export const analysisLoadingMessages = [
  { zh: 'AI侦探正在破译文本密码...', en: 'AI detective decoding text patterns...' },
  { zh: '显微镜下观察中，请勿打扰...', en: 'Examining under microscope, do not disturb...' },
  { zh: '正在细细品味每一个字...', en: 'Savoring every word carefully...' },
  { zh: '文字DNA检测进行中...', en: 'Running text DNA analysis...' },
  { zh: '扫描文章的"指纹"...', en: 'Scanning the article\'s fingerprints...' },
  { zh: '让AI读三遍再说话...', en: 'Let AI read it thrice before speaking...' },
  { zh: '正在用AI的眼光审视文本...', en: 'Viewing text through AI\'s eyes...' },
  { zh: '深度学习正在深度思考...', en: 'Deep learning is thinking deeply...' },
  { zh: '逐字逐句，不放过任何细节...', en: 'Word by word, missing no detail...' },
  { zh: '算法正在解读隐藏信息...', en: 'Algorithms decoding hidden messages...' },
];

// Structure analysis specific messages
// 结构分析提示语
export const structureAnalysisMessages = [
  { zh: '正在绘制文章骨架图...', en: 'Drawing the article skeleton...' },
  { zh: 'X光透视文章结构中...', en: 'X-raying the article structure...' },
  { zh: '拆解文章零件，分析中...', en: 'Disassembling article parts for analysis...' },
  { zh: '建筑师审视蓝图中...', en: 'Architect reviewing blueprints...' },
  { zh: '正在寻找逻辑链条...', en: 'Finding the logic chains...' },
  { zh: '段落间的秘密正在揭晓...', en: 'Secrets between paragraphs revealing...' },
  { zh: '框架分析师努力工作中...', en: 'Framework analyst working hard...' },
  { zh: '正在理清文章脉络...', en: 'Untangling the article\'s veins...' },
];

// Suggestion generation messages
// 建议生成提示语
export const suggestionLoadingMessages = [
  { zh: '灵感小精灵正在头脑风暴...', en: 'Inspiration sprites brainstorming...' },
  { zh: '正在调配文字配方...', en: 'Mixing the word recipe...' },
  { zh: '文字魔法师施法中...', en: 'Word wizard casting spells...' },
  { zh: '创意引擎预热中...', en: 'Creative engine warming up...' },
  { zh: '寻找最佳改写方案...', en: 'Finding the best rewrite solution...' },
  { zh: '人类化处理进行中...', en: 'Humanization processing...' },
  { zh: '正在为您量身定制建议...', en: 'Tailoring suggestions just for you...' },
  { zh: '智慧结晶正在凝聚...', en: 'Crystallizing wisdom...' },
  { zh: '修辞专家审稿中...', en: 'Rhetoric expert reviewing...' },
  { zh: '正在给文字做SPA...', en: 'Giving words a spa treatment...' },
];

// Transition analysis messages
// 衔接分析提示语
export const transitionAnalysisMessages = [
  { zh: '正在检查段落间的握手...', en: 'Checking handshakes between paragraphs...' },
  { zh: '桥梁工程师检查连接处...', en: 'Bridge engineer inspecting connections...' },
  { zh: '寻找文章的流动之美...', en: 'Finding the flow of beauty...' },
  { zh: '正在追踪思维的轨迹...', en: 'Tracing the tracks of thought...' },
  { zh: '逻辑交通警察巡逻中...', en: 'Logic traffic police patrolling...' },
  { zh: '评估文章的节奏韵律...', en: 'Evaluating article rhythm...' },
];

// Upload/processing messages
// 上传/处理提示语
export const uploadLoadingMessages = [
  { zh: '正在打包您的文字行李...', en: 'Packing your word luggage...' },
  { zh: '文件传送门开启中...', en: 'File portal opening...' },
  { zh: '数据快递员正在派送...', en: 'Data courier delivering...' },
  { zh: '正在给文章办理入住...', en: 'Checking your article in...' },
  { zh: '文件正在通过安检...', en: 'File going through security...' },
  { zh: '搬运工小心翼翼搬运中...', en: 'Movers handling with care...' },
];

// Paragraph-specific suggestion messages
// 段落建议提示语
export const paragraphSuggestionMessages = [
  { zh: '正在为这段文字把脉...', en: 'Taking this paragraph\'s pulse...' },
  { zh: '段落诊所会诊中...', en: 'Paragraph clinic consulting...' },
  { zh: '文字理疗师处理中...', en: 'Word therapist treating...' },
  { zh: '正在给这段话做CT扫描...', en: 'CT scanning this paragraph...' },
  { zh: '改写配方调制中...', en: 'Mixing rewrite formula...' },
  { zh: '润色魔法准备释放...', en: 'Polish magic ready to release...' },
  { zh: '语言美容师设计方案中...', en: 'Language beautician designing...' },
  { zh: '正在思考如何让它更自然...', en: 'Thinking how to make it more natural...' },
];

/**
 * Get a random loading message from a specific category
 * 从特定类别获取随机加载消息
 */
export function getRandomLoadingMessage(
  category: 'general' | 'analysis' | 'structure' | 'suggestion' | 'transition' | 'upload' | 'paragraph' = 'general'
): { zh: string; en: string } {
  const messageMap = {
    general: generalLoadingMessages,
    analysis: analysisLoadingMessages,
    structure: structureAnalysisMessages,
    suggestion: suggestionLoadingMessages,
    transition: transitionAnalysisMessages,
    upload: uploadLoadingMessages,
    paragraph: paragraphSuggestionMessages,
  };

  const messages = messageMap[category];
  return messages[Math.floor(Math.random() * messages.length)];
}

/**
 * Get multiple random loading messages (for rotating display)
 * 获取多个随机消息（用于轮播显示）
 */
export function getRandomLoadingMessages(
  category: 'general' | 'analysis' | 'structure' | 'suggestion' | 'transition' | 'upload' | 'paragraph' = 'general',
  count: number = 5
): Array<{ zh: string; en: string }> {
  const messageMap = {
    general: generalLoadingMessages,
    analysis: analysisLoadingMessages,
    structure: structureAnalysisMessages,
    suggestion: suggestionLoadingMessages,
    transition: transitionAnalysisMessages,
    upload: uploadLoadingMessages,
    paragraph: paragraphSuggestionMessages,
  };

  const messages = [...messageMap[category]];
  const shuffled = messages.sort(() => Math.random() - 0.5);
  return shuffled.slice(0, Math.min(count, shuffled.length));
}

/**
 * React hook for rotating loading messages
 * 用于轮播加载消息的 React hook
 */
import { useState, useEffect } from 'react';

export function useRotatingLoadingMessage(
  category: 'general' | 'analysis' | 'structure' | 'suggestion' | 'transition' | 'upload' | 'paragraph' = 'general',
  intervalMs: number = 3000
): { zh: string; en: string } {
  const [message, setMessage] = useState(() => getRandomLoadingMessage(category));

  useEffect(() => {
    const interval = setInterval(() => {
      setMessage(getRandomLoadingMessage(category));
    }, intervalMs);

    return () => clearInterval(interval);
  }, [category, intervalMs]);

  return message;
}

/**
 * Simple loading message component props
 * 简单加载消息组件属性
 */
export interface LoadingMessageProps {
  category?: 'general' | 'analysis' | 'structure' | 'suggestion' | 'transition' | 'upload' | 'paragraph';
  rotate?: boolean;
  intervalMs?: number;
  showEnglish?: boolean;
  className?: string;
}

/**
 * Estimate wait time based on document character count
 * 根据文档字符数估算等待时间
 *
 * Based on empirical data: ~14 chars/second for LLM structure analysis
 * 基于经验数据：LLM结构分析约14字符/秒
 *
 * @param charCount Document character count
 * @param analysisType Type of analysis being performed
 * @returns Estimated time in seconds and formatted string
 */
export function estimateWaitTime(
  charCount: number,
  analysisType: 'structure' | 'suggestion' | 'transition' | 'paragraph' = 'structure'
): { seconds: number; formatted: string; timeoutMs: number } {
  // Base processing rates (chars per second)
  // 基础处理速率（字符/秒）
  const processingRates = {
    structure: 14,      // ~3 min for 2800 chars
    suggestion: 50,     // Faster per-sentence processing
    transition: 30,     // Medium speed for transition analysis
    paragraph: 40,      // Paragraph restructuring
  };

  // Minimum and maximum times (seconds)
  // 最小和最大时间（秒）
  const minTime = 30;   // At least 30 seconds
  const maxTime = 600;  // Max 10 minutes

  // Calculate base estimate
  // 计算基础估算
  const rate = processingRates[analysisType];
  const baseEstimate = Math.ceil(charCount / rate);

  // Add 20% buffer for network and processing overhead
  // 添加20%缓冲用于网络和处理开销
  const estimatedSeconds = Math.min(maxTime, Math.max(minTime, Math.ceil(baseEstimate * 1.2)));

  // Format time string
  // 格式化时间字符串
  let formatted: string;
  if (estimatedSeconds < 60) {
    formatted = `约${estimatedSeconds}秒 / ~${estimatedSeconds}s`;
  } else if (estimatedSeconds < 120) {
    formatted = `约1-2分钟 / ~1-2 min`;
  } else if (estimatedSeconds < 180) {
    formatted = `约2-3分钟 / ~2-3 min`;
  } else if (estimatedSeconds < 300) {
    formatted = `约3-5分钟 / ~3-5 min`;
  } else {
    formatted = `约5-10分钟 / ~5-10 min`;
  }

  // Calculate timeout with 50% buffer
  // 计算超时时间，增加50%缓冲
  const timeoutMs = Math.min(600000, Math.max(60000, estimatedSeconds * 1500));

  return { seconds: estimatedSeconds, formatted, timeoutMs };
}

/**
 * React hook for countdown timer display
 * 用于倒计时显示的 React hook
 */
export function useCountdownTimer(
  initialSeconds: number,
  isActive: boolean = true
): { remaining: number; formatted: string; isOvertime: boolean } {
  const [remaining, setRemaining] = useState(initialSeconds);
  const [isOvertime, setIsOvertime] = useState(false);

  useEffect(() => {
    if (!isActive) return;

    // Reset when initialSeconds changes
    // 当 initialSeconds 改变时重置
    setRemaining(initialSeconds);
    setIsOvertime(false);

    const interval = setInterval(() => {
      setRemaining(prev => {
        const newValue = prev - 1;
        if (newValue <= 0) {
          setIsOvertime(true);
        }
        return newValue;
      });
    }, 1000);

    return () => clearInterval(interval);
  }, [initialSeconds, isActive]);

  // Format remaining time
  // 格式化剩余时间
  const absRemaining = Math.abs(remaining);
  const minutes = Math.floor(absRemaining / 60);
  const seconds = absRemaining % 60;
  const formatted = isOvertime
    ? `已超时 +${minutes}:${seconds.toString().padStart(2, '0')}`
    : `${minutes}:${seconds.toString().padStart(2, '0')}`;

  return { remaining, formatted, isOvertime };
}
